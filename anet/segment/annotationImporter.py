'''
Introduction
============

Module to read in manually generated cell segmentation results with different
formats. Data is organized in different data categories, e.g. for training and validation,
and can contain different channels, e.g. DAPI for nuclei and Cy5 for cells.

Results are stored in a dictionary ("annotDict") containing all relevant
information. In the usual workflow, this dictonary is  used with the
MaskGenerator module to generate different masks, which can be used with
the neural network.

annotDict[data_category][channel][misc_dict]

[data_category] can be 'Training', 'Validation','Test', ...
[channel] can be 'cells', 'nuclei', ....
[misc_dict] can be different dictonaries. The ones generated by this modules are
'images' (for the actual images), and 'roi' for a list of all defined regions
for a given image. Each data-set is stored with the full path name
as a key, and the actual data as an item. Other diconaries, e.g. containing
the actual masks (generated by the MaskGenerator) can then be added.

'''

# ---------------------------------------------------------------------------
# Imports
# ---------------------------------------------------------------------------
import os
from skimage import io
import numpy as np

from read_roi import read_roi_zip # https://github.com/hadim/read-roi

# ---------------------------------------------------------------------------
# Globals
# ---------------------------------------------------------------------------

__version__ = '0.0.0'
__author__ = 'Florian MUELLER'
__email___ = 'muellerf.research@gmail.com'

# ---------------------------------------------------------------------------
# Classes
# ---------------------------------------------------------------------------


class AnnotationImporter():
    '''Base class for annotation importer'''

    def load(self, path_open):
        ''' Load images and annotations;
            return two lists with images and annotations (ROIs)
        '''
        raise NotImplementedError('No load function defined for this class!')


class FolderImporter(AnnotationImporter):
    ''' Class to import manual annotations from folder.

    Args:
        channels: is a dictonary specifying the different channels. The keys
        will be used to contruct the annotation dictonary. The items correspond
        to unique identifiers contained in the file-name. Replacing one
        identifier by the other has to yield the corresponding file-name

        roitype: specifies with type of annotation is used.
            'imagej' .... ImageJ ROIs

        img_ext: specifies the extension of the images

        data_category: is a dictonary specifying the different data categories.
        Each data category has a dedicated folder with the specified name. This
        name will also be used to construct the dictionary. For instance, if
        the category 'train' has the identifier 'train', then 'train' has to
        be contained in the full file-name as a dedicated sub-folder
        called 'train'.
    '''

    def __init__(self, channels={'cells': 'Cy5', 'nuclei': 'DAPI'}, annot_type='imagej', img_ext='.tif', annot_ext = '_ROI.zip', data_category={'train': 'train', 'valid': 'valid'}):
        ''' Initiate annotation dictionary '''

        # Generate dictionary and save config
        self.annotDict = {}
        self.annotDict['config'] = {}
        self.annotDict['config']['channels'] = channels
        self.annotDict['config']['annot_type'] = annot_type
        self.annotDict['config']['img_ext'] = img_ext
        self.annotDict['config']['annot_ext'] = annot_ext
        self.annotDict['config']['data_category'] = data_category

        # Create list of of all channels
        self.channel_list = [i for i in channels.items()]

        # Create dictionary entry for each data category
        for key_data in data_category.keys():
            d = {}
            self.annotDict[key_data] = d
            for key_ch in channels.keys():
                d[key_ch] = {}

        # Generate
        self.annotDict['config']['roi_size'] = {}
        for key_ch in channels.keys():
            self.annotDict['config']['roi_size'][key_ch] = []

    def load(self, path_open):
        ''' 'Read folder content based on defined config.
        Args:
        path_open: folder name containg the images and annotations for data-set.
        '''

        annotDict = self.annotDict.copy()
        roi_size_all  = self.annotDict['config']['roi_size'].copy()
        roi_size_mean = self.annotDict['config']['roi_size'].copy()

        # Loop over data categories and verify if corresponding folder exists
        for key_categ, categ in self.annotDict['config']['data_category'].items():

            # Construct folder name for data cateogry and verify if it exists
            folder_data = os.path.join(path_open, categ)
            if not os.path.isdir(folder_data):
                print('WARNING: folder for data category "{}" does not exist'.format(categ))
                print(folder_data)
                continue

            # Loop over folder content
            for file_name in os.listdir(folder_data):

                # Test different channels
                for key_channel, channel in self.annotDict['config']['channels'].items():

                    # Continue only if file name ends with the specified extension
                    if (channel in file_name) and file_name.endswith(self.annotDict['config']['img_ext']) and (not('/._' in file_name)):

                        # Load image
                        file_path = os.path.join(folder_data, file_name)
                        img_load = io.imread(file_path)

                        # Load annotation
                        if self.annotDict['config']['annot_type'] == 'imagej':
                            # Get file name of annotation
                            annote_name_full = os.path.join(
                                path_open, categ, file_name.replace(self.annotDict['config']['img_ext'], self.annotDict['config']['annot_ext']))

                            if os.path.isfile(annote_name_full):
                                roi_dict_complete = read_roi_zip(annote_name_full)
                            else:
                                print('WARNING: file with annotations "{}" not found'.format(annote_name_full))
                                continue

                        else:
                            raise Exception('unsupported roi file type')

                        # Simplify dictionary & get size of ROIS
                        roi_dict = {}
                        for k, v in roi_dict_complete.items():

                            # Simplified dictionary: coordinates and annotation type
                            roi_dict[k] = {}
                            roi_dict[k]['pos'] = np.column_stack((v['y'], v['x']))
                            roi_dict[k]['type'] = v['type']

                            # Store size of regions
                            roi_size_all[key_channel].append(
                            [roi_dict[k]['pos'][:, 0].max() - roi_dict[k]['pos'][:, 0].min(),
                             roi_dict[k]['pos'][:, 1].max() - roi_dict[k]['pos'][:, 1].min()])

                        # Assign to dictionary
                        annotDict[key_categ][key_channel][file_name] = {
                        'image': img_load, 'roi': roi_dict}


        # Calculate the bounding box size for each ROIs in each channel
        for k, v in roi_size_all.items():
            roi_size_mean[k] = np.mean(v, axis=0)

        annotDict['roi_size'] = roi_size_mean

        return annotDict


# ---------------------------------------------------------------------------
# Functions
# ---------------------------------------------------------------------------


def bin_dict(dict, bin_factor, interp='bilinear'):
    ''' Function to bin annotation dictonary. Performed with
    scipy.misc.imresize
    Binning is determined by the bin_factor. Function supports default behavior
    - int ... Percentage of current size
    - float ... Fraction of current size

    bin_factor can also be set to a string corresponding to one of the channels.
    In this case the binning is calculated automatically based on the mean size
    of the annotated objects in this channel.
    '''

    from scipy.misc import imresize
    import copy

    dict_bin = copy.deepcopy(dict)

    # Rescale ROIs
    if isinstance(bin_factor, int):
        scale_roi = bin_factor / 100
    elif isinstance(bin_factor, float):
        scale_roi = bin_factor

    print('scale roi:', scale_roi)

    for key_cat in dict_bin['data_category'].keys():
        for key_ch in dict_bin['channels'].keys():
            for key_data in dict_bin[key_cat][key_ch].keys():

                # Assign resized image
                dict_bin[key_cat][key_ch][key_data]['image'] = imresize(
                    dict_bin[key_cat][key_ch][key_data]['image'], bin_factor, interp=interp, mode='F')

                # Resize roi
                for key_roi, val_roi in dict_bin[key_cat][key_ch][key_data]['roi'].items():
                    dict_bin[key_cat][key_ch][key_data]['roi'][
                        key_roi]['pos'] = np.round(val_roi['pos'] * scale_roi).astype('int64')
    return dict_bin
